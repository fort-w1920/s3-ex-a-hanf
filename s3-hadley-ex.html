<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Lektüre &amp; Quiz: <code>S3</code></title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>Lektüre &amp; Quiz: <code>S3</code></h2>

<p>Lesen Sie das <a href="https://adv-r.hadley.nz/s3.html"><code>S3</code></a> Kapitel von H. Wickham&#39;s <em>Advanced R</em>. 
Bearbeiten Sie (mindestens) die folgenden von dort übernommenen/inspirierten Aufgaben:</p>

<ul>
<li>Was tut die <code>as.data.frame.data.frame()</code> Methode? Warum ist das verwirrend? Wie können Sie derartige Verwirrung in Ihrem eigenen Code vermeiden?</li>
</ul>

<p>Aus der Doku: &ldquo;Functions to check if an object is a data frame, or coerce it if possible&rdquo; -&gt; Diese Funktion wird aufgerufen, wenn man für ein <code>data.frame</code>-Objekt die Funktion <code>as.data.frame()</code> aufruft.
Verwirrend:
<code>data.frame</code> ist der Helper für Dataframes und nicht die <code>data()</code> Methode für die Klasse <code>frame</code>. Hier ist einfach die Benennung ungünstig. Besser: <code>data_frame()</code> oder <code>dataFrame()</code>
Dasselbe trifft auf <code>as.data.frame</code> zu -&gt; ist das die <code>as.data()</code> Methode der Klasse <code>frame</code> oder die <code>as()</code> Methode der Klasse <code>data.frame</code>? Besser: <code>as_data_frame()</code> =&gt; <code>as_data_frame.dataFrame()</code> wäre zum Beispiel eine besser lesbare Möglichkeit.</p>

<ul>
<li>Beschreiben/erklären Sie das Verhalten dieses Codes:</li>
</ul>

<pre><code class="r">set.seed(1014)
some_days &lt;- as.Date(&quot;2019-11-24&quot;) + sample(10, 5)
mean(some_days)
</code></pre>

<pre><code>## [1] &quot;2019-11-30&quot;
</code></pre>

<pre><code class="r">mean(unclass(some_days))
</code></pre>

<pre><code>## [1] 18230.4
</code></pre>

<p><code>some_days</code> ist ein Objekt der Klasse <code>date</code> (double-Vektor mit Klassenattribute <code>&quot;Date&quot;</code>). Die Klasse <code>Date</code> überschreibt die Methode <code>&quot;+&quot;</code>:</p>

<pre><code class="r">print(getS3method(&quot;+&quot;, &quot;Date&quot;))
</code></pre>

<pre><code>## function (e1, e2) 
## {
##     coerceTimeUnit &lt;- function(x) as.vector(round(switch(attr(x, 
##         &quot;units&quot;), secs = x/86400, mins = x/1440, hours = x/24, 
##         days = x, weeks = 7 * x)))
##     if (nargs() == 1L) 
##         return(e1)
##     if (inherits(e1, &quot;Date&quot;) &amp;&amp; inherits(e2, &quot;Date&quot;)) 
##         stop(&quot;binary + is not defined for \&quot;Date\&quot; objects&quot;)
##     if (inherits(e1, &quot;difftime&quot;)) 
##         e1 &lt;- coerceTimeUnit(e1)
##     if (inherits(e2, &quot;difftime&quot;)) 
##         e2 &lt;- coerceTimeUnit(e2)
##     .Date(unclass(e1) + unclass(e2))
## }
## &lt;bytecode: 0x55ed55bdc350&gt;
## &lt;environment: namespace:base&gt;
</code></pre>

<p>Dadurch kann der gesampelte Vektor addiert werden (in diesem Fall erfolgt die Addition als double via <code>unclass</code>) und dann wieder als Datum konvertiert werden. Die Klasse <code>&quot;Date&quot;</code> implementiert auch eine Methode für <code>mean</code>:</p>

<pre><code class="r">print(getS3method(&quot;mean&quot;, &quot;Date&quot;))
</code></pre>

<pre><code>## function (x, ...) 
## .Date(mean(unclass(x), ...))
## &lt;bytecode: 0x55ed55ffb6d8&gt;
## &lt;environment: namespace:base&gt;
</code></pre>

<p>Es wird also wieder mit <code>unclass</code> auf die double-Werte zurückgegriffen und der Mean berechnet, anschließend dann als Date zurückkonvertiert. Beim Aufruf von <code>mean(unclass(some_days))</code> fehlt diese Konversion und man bekommt den double angezeigt. <code>.Date(mean(unclass(some_days)))</code> liefert dasselbe Ergebnis wie <code>mean(some_days)</code>.</p>

<ul>
<li>Welche Klasse hat <code>x</code> im folgenden Code? Auf welchem <em>base type</em> basiert diese Klasse? Welche Attribute nutzt sie und wie sind die mathematischen Eigenschaften von Verteilungsfunktionen hier konkret implementiert? </li>
</ul>

<pre><code class="r">x &lt;- ecdf(rpois(100, 10))
x
</code></pre>

<pre><code>## Empirical CDF 
## Call: ecdf(rpois(100, 10))
##  x[1:18] =      2,      3,      4,  ...,     18,     19
</code></pre>

<p>Klassen von x:</p>

<pre><code class="r">print(class(x))
</code></pre>

<pre><code>## [1] &quot;ecdf&quot;     &quot;stepfun&quot;  &quot;function&quot;
</code></pre>

<p>Basistyp von x:</p>

<pre><code class="r">print(typeof(x))
</code></pre>

<pre><code>## [1] &quot;closure&quot;
</code></pre>

<p>Attribute von x:</p>

<pre><code class="r">print(attributes(x))
</code></pre>

<pre><code>## $class
## [1] &quot;ecdf&quot;     &quot;stepfun&quot;  &quot;function&quot;
## 
## $call
## ecdf(rpois(100, 10))
</code></pre>

<p>Die mathematischen Eigenschaften sind im Konstruktor sichergestellt:</p>

<pre><code class="r">print(ecdf)
</code></pre>

<pre><code>## function (x) 
## {
##     x &lt;- sort(x)
##     n &lt;- length(x)
##     if (n &lt; 1) 
##         stop(&quot;&#39;x&#39; must have 1 or more non-missing values&quot;)
##     vals &lt;- unique(x)
##     rval &lt;- approxfun(vals, cumsum(tabulate(match(x, vals)))/n, 
##         method = &quot;constant&quot;, yleft = 0, yright = 1, f = 0, ties = &quot;ordered&quot;)
##     class(rval) &lt;- c(&quot;ecdf&quot;, &quot;stepfun&quot;, class(rval))
##     assign(&quot;nobs&quot;, n, envir = environment(rval))
##     attr(rval, &quot;call&quot;) &lt;- sys.call()
##     rval
## }
## &lt;bytecode: 0x55ed5623efb0&gt;
## &lt;environment: namespace:stats&gt;
</code></pre>

<p>Für die Werte, die im übergebenen Vektor vorkommen, wird der Wert der empirischen Verteilungsfunktion berechnet. Zuerst werden die Werte im übergebenen Vektor sortiert. Tabulate zählt, wie oft ein Wert im Vektor vorkommt, cumsum nimmt dann die kumulative Summe -&gt; noch durch die Anzahl an Beobachtungen teilen und fertig. Anschließend wird mit <code>approxfun</code> konstant interpoliert. Über approxfun werden auch die Werte links und rechts von den übergebenenen Beobachtungen fixiert (mit 0 für kleinere Werte und 1 für größere).</p>

<ul>
<li>Schreiben Sie einen neuen low-level Konstruktor für <code>data.frame</code>-Objekte (ohne die Funktionen <code>as.data.frame()</code> oder <code>data.frame()</code> zu benutzen, selbstverständlich). Machen Sie sich zunächst klar: Auf welchem <em>base type</em> basiert <code>data.frame</code>? Welche Attribute nutzt <code>data.frame</code>? Welche Restriktionen gelten für die verschiedenen Einträge und Attribute?<br/>
<em>Hinweis</em>: Sehen Sie sich dafür zunächst mal so etwas wie <code>str(unclass(&lt;irgend ein data.frame&gt;))</code> an.</li>
</ul>

<pre><code class="r">check_datatype &lt;- function(data) {
  allowed_datatypes &lt;- c(&quot;logical&quot;, &quot;integer&quot;, &quot;double&quot;, &quot;complex&quot;, &quot;character&quot;)
  if (!(typeof(data) %in% allowed_datatypes)) {
    stop(paste(&quot;Wrong input data type. Allowed types are: 
               logical, integer, double, complex, character&quot;))
  }
}

name_df_column &lt;- function(row.names, current_input, column=&quot;&quot;) {
  if (!(is.null(row.names))) {
     return(paste(row.names[current_input], column, sep = &quot;&quot;))
  } 
  return(paste(&quot;X&quot;, current_input, column, sep = &quot;&quot;))
}

new_data.frame &lt;- function(..., row.names=NULL) {
  input_data &lt;- list(...)
  num_inputs &lt;- length(input_data)
  result &lt;- list()
  num_cols &lt;- 0

  for (current_input in seq_len(num_inputs)) {
    current_data &lt;- input_data[[current_input]]
    current_datatype &lt;- typeof(current_data)
    check_datatype(current_datatype)


    if (is.null(dim(current_data)) || dim(current_data)[[2]] == 1) {
      # handle vector inputs
      num_cols &lt;- num_cols + 1
      column_name &lt;- name_df_column(row.names, current_input)
      result[[column_name]] &lt;- current_data
    } else {
      # matrix-like inputs are handled by iterating over the provided columns
      num_cols &lt;- num_cols + dim(current_data)[[2]]
      for (column in seq_len(dim(current_data)[[2]])) {
        column_name &lt;- name_df_column(row.names, current_input, column)
        result[[column_name]] &lt;- current_data[, column]
      }
    }
  }

  class(result) &lt;- &quot;data.frame&quot;

  # set row names from argument or infer them
  if (!is.null(row.names)) row.names(result) &lt;- row.names
  else row.names(result) &lt;- seq_len(length(result[[1]]))
  result
} 

str(unclass(data.frame(matrix(1, nrow = 2, ncol = 2))))
</code></pre>

<pre><code>## List of 2
##  $ X1: num [1:2] 1 1
##  $ X2: num [1:2] 1 1
##  - attr(*, &quot;row.names&quot;)= int [1:2] 1 2
</code></pre>

<pre><code class="r">str(unclass(new_data.frame(matrix(1, nrow = 2, ncol = 2))))
</code></pre>

<pre><code>## List of 2
##  $ X11: num [1:2] 1 1
##  $ X12: num [1:2] 1 1
##  - attr(*, &quot;row.names&quot;)= int [1:2] 1 2
</code></pre>

<pre><code class="r">str(unclass(data.frame(c(1,2,3,4,5))))
</code></pre>

<pre><code>## List of 1
##  $ c.1..2..3..4..5.: num [1:5] 1 2 3 4 5
##  - attr(*, &quot;row.names&quot;)= int [1:5] 1 2 3 4 5
</code></pre>

<pre><code class="r">str(unclass(new_data.frame(c(1,2,3,4,5))))
</code></pre>

<pre><code>## List of 1
##  $ X1: num [1:5] 1 2 3 4 5
##  - attr(*, &quot;row.names&quot;)= int [1:5] 1 2 3 4 5
</code></pre>

<ul>
<li>Kategorisieren Sie die Klassen der Rückgabe-Objekte von <code>lm(), factor(), table(), as.Date(), as.POSIXct(), ecdf(), ordered(), I()</code> in die Klassentypen <em>vector class</em>, <em>record style class</em>, <em>scalar class</em> die in <em>Advanced R</em> beschrieben  werden.</li>
</ul>

<p>vector style class: <code>factor(), as.Date(), ordered()</code></p>

<p>record style class: <code>table(), as.POSIXct()</code></p>

<p>scalar class: <code>lm(), ecdf()</code></p>

<p><code>I()</code> sollte den Klassentypen nicht ändern, da lediglich eine (sehr seltsame?!) Klasse zum Objekt hinzugefügt wird -&gt; selber Klassentyp wie übergebenes Argument</p>

<ul>
<li>Wie sähe ein Konstruktor <code>new_lm</code> für Objekte der Klasse <code>lm</code> aus? Warum wäre ein solcher Konstruktor vermutlich nicht besonders nützlich? </li>
</ul>

<p>Ich verstehe die Frage nicht. Im Konstruktor muss geprüft werden, ob die übergebenen Argumente syntaktisch sinnvoll sind (<code>formula</code> ist eine Formel, <code>data</code> kann in einen Dataframe überführt werden usw.) und zusätzlich das Modell erstellt werden. Da passiert inhaltlich eine ganze Menge. Vielleicht verstehe ich falsch, was ein &ldquo;solcher Konstruktor&rdquo; ist?</p>

<ul>
<li>Lesen Sie den Quellcode für <code>t()</code> und <code>t.test()</code>. Ist <code>t.test()</code> eine generische S3 Funktion oder eine S3 Methode? Was passiert im Detail wenn sie <code>t()</code> auf ein S3-Objekt mit Klasse <code>test</code> anwenden (s.u.)? Warum?</li>
</ul>

<pre><code class="r">x &lt;- structure(1:10, class = &quot;test&quot;)
t(x)
</code></pre>

<pre><code>## 
##  One Sample t-test
## 
## data:  x
## t = 5.7446, df = 9, p-value = 0.0002782
## alternative hypothesis: true mean is not equal to 0
## 95 percent confidence interval:
##  3.334149 7.665851
## sample estimates:
## mean of x 
##       5.5
</code></pre>

<p>t.test ist eine generische S3 Funktion. Es wird <code>UseMethod</code> aufgerufen, um einen t-test für das jeweilige Objekt durchzuführen (es sind Methoden für <code>formula</code>-Objekte und den <code>default</code>-Fall implementiert). Beim Aufruf von <code>t(x)</code> startet der Method Dispatch in der generischen Funktion <code>t()</code> und sucht als erstes nach einer Funktion <code>t.test</code>, da die Klasse von <code>x</code> <code>test</code> ist. Diese wird gefunden (weil <code>t.test</code> furchtbar benannt wurde), somit führen wir den t-Test durch. Das ist sicher nicht so gedacht gewesen und wäre vermeidbar, wenn <code>t.test</code> einfach <code>t_test</code> heißen würde.</p>

</body>

</html>
